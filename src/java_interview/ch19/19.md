# 비트 조작
## 부울 연산자
```java
> true && false
false
> true || false
true
> !ture
false
```
- `AND`, `OR`, `NOT`은 기본 부울 연산자
  - 서로 결합하거나 조합하면 다른 보조 연산을 만들어 낼 수 있다.
  - `XOR`이 대표적인 보조 연산 [같으면 false, 다르면 true]
    ```java
    > boolean x = ture, y= false
    x ==> true
    y ==> false
    > (x && y) || (x! && y)
    false
    ```
## 비트 연산자
- 비트 연산은 주로 정수의 비트 단위 논리 연산을 할 때 사용
```java
> 11 & 9
9
> 0b1011 & 0b1001
9
```
- 정수 11과 9를 10진법으로 표현하거나 또는 2진법으로 표현해도 비트 연산 결과는 동일하게 작동
```java
> ~ 0b1
-2
```
- 비트 연산자 `NOT`인 `~`를 2진법 1에 적용하면 -2가 된다.
  - 2의 보수 음수를 표현해서 1을 뺀 값이며, 이 값은 음숫값에서 1을 뺀 값
  - `NOT x = -x -1`을 의미
## 비트 조작 퀴즈
- 덧셈인 `0b0110 + 0b0010`
  - 자릿수가 초기화될 때마다 다음 자리로 넘겨주는 십진수 덧셈과 동일하게 처리
- 곱셈인 `0b0011 * 0b0101`
  - 이진수의 곱셈과 십진수의 곱셈과 동일
  - 0은 모두 0이 되고, 1은 기존의 값 그대로 내려온다.
- 시프팅 연산
  ```java
  > 0b1101 >> 2
  3
  > 0b1101 << 2
  52
  ```
  - `>>`이 바로 시프팅 연산
  - `0b1101 >> 2` 1101을 오른쪽으로 2칸 시프팅하겠다는 의미
    - 1101 -> 0011 : 뒤에 두 자리가 잘려나가 결과는 3이 된다.
    - 값이 1/4 만큼 줄어듦
  - `0b1101 << 2` 1101을 왼쪽으로 2칸 시프팅하겠다는 의미
    - 1101 -> 110100 : 뒤에 두 자리인 00이 추가되므로 결과는 52가 된다.
  - 만약 자료형이 32비트라면, 좌측 시프팅은 최대 크기가 정해져 있기 떄문에 맨 끝 값이 31칸 까지만 시프팅된다.
  - 반면 우측 시프팅은 자료형의 크기와 관계없이 항상 줄어든다.
``` java
> 0b0101 ^ ~0b1100
-10
```
- `NOT` 연산인 ~0b1100은 0b0011이 되고, 여기에 `XOR` 연산을 통해 0b0110이 나오리라 기대
  - 0b0110은 십진수로 6, 하지만 실제 결과는 -10
- 결괏값이 달라진 이유
  - `NOT x = -x -x` 따라서 `-12 - 1 = -13`
  - -13을 2의 보수로 표현하면 11111...110011
  - 32비트 정수형이라면 앞에 28비트는 모두 1
  - 앞에 값은 0b0101이므로 이 값과 함께 `XOR`연산을 한 결과 111111...110110
  - 2의 보수 음수 표현일 때 십진숫값은 -10
### 자릿수 제한 비트 연산
- 0b1100을 우리는 12로 보지 않는다.
  - 2의 보수일 때 이 값은 -4
  - 2의 보수에서 맨 왼쪽 값은 부호를 뜻하기 때문에 0b1100이 12가 되려면 비트 수가 좀 더 늘어나 앞에 0이 더 붙어 있어야 한다.
  - 전체가 5비트라면 0b01100일 때 12가 맞지만 4비트에서는 0b0011은 맨 왼쪽 값이 자릿수로 빠져서 -4가 된다.
- 우리가 기대했던 것은 `~0b1100`이 `0b0011`으로 바뀌는 것
  - 자릿수를 4비트로 제한하는 별도의 부가 작업이 필요
  - 자릿수만큼의 **최댓값**을 지닌 비트 마스크 `MASK`를 만들고, 그 값과 `XOR`을 통해 값을 만들자.
    ```java
    > int MASK = 0b1111
    MASK ==> 15
    > 0b1100 ^ MASK
    3
    ```
    - 십진수 3은 이진수로 표현하면 0011
    - 각 비트 단위에서 0은 1이 되고, 1은 0이 되었으니 우리가 원하는 뒤집힌 값
  ```java
  > int MASK = 0b1111
  MASK ==> 15
  > 0b0101 ^ (0b1100 ^ MASK)
  6
  ```
  - `MASK`를 통해 자릿수를 제한하니 우리가 원하는 값인 6이 나오게 된다.
## 2의 보수
- 2의 보수는 컴퓨터가 숫자를 표현하기 위한 여러 표기법중 하나로 음수를 효과적으로 표현할 수 있다.
### 2의 보수 표현
- 4비트로 표현 가능한 범위는 0000~1111로 총 16개
  - 양수만 저장한다면 0~15까지 그대로 저장하면 된다.
- 하지만 정수는 양수뿐만 아니라 음수도 저장해야 한다.
  - 자바는 c언어의 `unsigned`와 다르게 양수로만 저장할 수 있는 자료형을 지원하지 않으므로 항상 양수와 음수를 함께 저장하며 2의 보수로 표현해야 한다.
  - 할당 범위 중 절반을 쪼개서 음수 몫으로 할당하고 나머지는 양수에 할당하는 식
  - 여기서 맨 앞 비트는 부포 비트(Most Significant Bit;MSB 최상위 비트)로 사용
    - 양수는 `0xxx`를 활용하고 음수는 `1xxx`를 활용
    - 0000 == 0 ~ 1111 == -1
- 4비트로 2의 보수를 표현하기 위해서는 비트 MASK를 활용
```java
> int MASK = 0b1111
MASK ==> 15
> Integer.toBinaryString(-8 & MASK)
1000
> Integer.toBinaryString(-1 & MASK)
1111
```
### 비트 연산자 `NOT`
- `~` 연산자인 비트 여난자 `NOT`은 기준 비트 내에서 정확히 1을 0으로, 0을 1로 바꿔주는 역할