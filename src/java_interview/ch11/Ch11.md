# 해시 테이블
- 해시 테이블(Hash Table) 또는 해시맵(Hash Map)은 키를 값으로 매핑할 수 있는 구조인, 연관 배열 추상 자료형(ADT)을 구현하는 자료
- 가장 큰 특징은 대부분의 연산이 분할 상환 분석에 따른 시간 복잡도가 O(1)이라는 것
- 데이터 양에 관계없이 빠른 성능을 기대할 수 있다는 장점이 있다.
## 해시
- 해시 함수란 임의 크기 데이터를 고정 크기 값으로 매핑하는 데 사용할 수 있는 함수를 의미
- 입력값의 수가 어떻든 간에 해시 함수를 통과하면 2바이트의 고정 크기 값으로 매핑
  - ABC -> A1
  - 1324BC -> CB
  - AF32B -> D5
- 해시 테이블을 인덱싱하기 위해 이처럼 해시 함수를 사용하는 것을 해싱(Hashing)이라고 한다.
  - 정보를 가능한 빠르게 저장하고 검색하기 위해 사용하는 중요한 기법 중 하나
  - 최적의 검색이 필요한 분야에 사용
  - 심볼 테이블등(일반적으로 해시 테이블로 구현)의 자료구조를 구현하기에도 적절
- 해시 함수는 체크섬, 손실 압축, 무작위화 함수, 암호 등과도 관련이 깊으며 때로는 서로 혼용되기도 한다.
- 성능 좋은 해시 함수듸 특징
  - 해시 함숫값 충돌의 최소화
  - 쉽고 빠른 연산
  - 해시 테이블 전체에 해시값이 균일하게 분포
  - 사용할 키의 모든 정보를 이용하여 해싱
  - 해시 테이블 사용 효율이 높을 것
## 생일 문제
- 생각보다 충돌은 쉽게 일어남
- 생일의 가짓수가 365개 이므로 여러 사람이 모였을 때 생일이 같은 2명이 존재할 확률을 얼핏 생각해보면 비둘기집 원리에 따라 366명 이상은 모여야 일어나는 일 같다
- 실제로는 23명만 모여도 50%를 넘고, 57명이 모이면 99%를 넘어선다.
- 충돌은 생각보다 쉽게 일어나므로 충돌을 최소화하는 일은 무엇보다 중요
## 비둘기집 문제
- n개의 아이템을 m개의 컨테이너에 넣을 때, n > m 이라면 적어도 하나의 컨테이너에는 반드시 2개 이상의 아이템이 들어 있다는 원리
- 서랍 원리라고도 불린다.
- 비둘기집 원리에 따라 9개의 공간이 있는 곳에 10개의 아이템이 들어온다면 반드시 1번 이상은 충돌이 발생
  - 생일문제에서 살펴 봤듯이 충돌은 더 자주 발생
- 좋은 해시함수라면 충돌을 최소화해 1번만 발생하게 한다면, 나쁜 해시함수는 심하면 9번 모두 충돌해 10개의 공간 중 1개의 공간만 사용할 수 있다.
- 여러 번 충돌한다는 것은 그만큼 추가 연산을 필요로 하기 때문에 가급적 충돌은 최소화하는 것이 좋다.
## 로드 팩터
- 충돌이 발생 했을 때, 충돌이 발생하기 전에 최적화를 하기위해서 일정 비율에 따라 해시 함수를 재작성해야 할지 또는 해시 테이블의 크기를 조정해야 할지를 결정
- 로드 팩터(Load Factor)란 해시 테이블에 저장된 데이터 개수 *n*을 버킷의 개수 *k*로 나눈 것
- 로드 팩터 = *n/k*
  - 해시 함수가 키들을 잘 분산해주는지를 말하는 효율성 측정에도 사용
- 자바 8버전부터 해시 테이블을 구현한 자료형인 해시 맵을 대폭 개선했으며 기본 로드 팩터를 0.75로 정하며, 이를 '시간과 공간 비용의 적절한 절충안'아리고 말했다
- 로드 팩터가 증가할수록 해시 테이블의 성능은 점점 감소하며, 자바는 이 값이 0.75를 넘어설 경우 동적 배열처럼 해시 테이블의 공간을 재할당
## 해시 함수
- 해싱에는 다양한 알고리즘이 있으며, 최상의 분포를 제공하는 방법은 데이터에 따라 제각각이다
- 정수형 해싱 기법인 모듈로 연산을 이용한 나눗셈 방식(Modulo-Division Method)
  - `h(x) = x mode m`
    - `h(x)` -> 입력값 `x`의 해시 함수를 통해 생성된 결과
    - `m`은 해시 테이블의 크기로 일반적으로 2의 멱수(거듭제곱으로 된 수)에 가깝지 않은 소수를 택하는 것이 좋다.
    - `h(x)`는 이 값의 모듈로 연산의 결과로, 매우 단순한 방법이지만 실무에서는 이미 많은 키 세트가 충분히 랜덤한 상태이고, 키 세트가 어떤 큰 소수에 의해 순환 구조가 될 확률은 낮기 때문에 실제로 잘 동작한다.
  - `x`는 어떤 간단한 **규칙**을 통해 만들어낸 충분히 랜덤한 상태의 **키의 값**
  - 조슈아 블로크는 자바를 설계할 때, 값 `x`를 다음과 같이 다항식의 결과로 정의
    - `P(x) = s[0] * x^(n - 1) + s[1] * x^(n - 2) + ... + s[n-1]`
    - 여기서 `x`는 31로 하는 거듭제곱 `P(31)`의 연산으로 정의했다고 밝힌 바 있다.
    - 31을 매직 넘버로 지정 -> 31은 메르센 소수로 수학적으로도 나쁜 선택이 아님
    - 실제 자바에 포함된 해시 코드중 일부
      - `hashCode = 31 * hashCode + (e == null ? 0 : e.hashCode());`
      - `e` 의 값을 더하면서 쌓아감. -> `P(x)`의 풀이와 비슷
## 충돌
- 아무리 좋은 해시 함수라도 충돌(Collision)은 발생한다
### 개별 체이닝
| *키* | *값* | *해시* | *충돌 여부* |
|-----|-----|------|---------|
| 카리나 | 15  | 2    | 충돌      |
| 지젤  | 47  | 1    |         |
| 윈터  | 17  | 2    | 충돌      |
| 닝닝  | 7   | 4    |         |
- 위 표를 개별 체이닝 방식으로 구현
  ![IMG_9465](https://github.com/JunRain2/practice-java/assets/107318116/cfefc8ac-eca1-44af-9410-9ca38928f6b9)
- 해시 테이블의 기본 방식이기도 한 개별 체이킹은 충돌 발생 시 이 그림과 같이 연결 리스트로 연결하는 방식
- 충돌이 발생한 '카리나'와 '윈터'는 '카리나' 다음 아이템이 '윈터'인 형태로 서로 연결 리스트로 연결 됐다
- 기본적인 자료구조와 임의로 정한 간단한 알고리즘만 있으면 되므로, 개별 체이닝 방식은 인기가 높다.
- 원래 해시 테이블 구조의 원형이기도 하며 가장 전통적인 방식으로, 흔히 해시 테이블이라고 하면 이 방식을 의미
- 절차
  1. 키의 해시값을 계산
  2. 해시값을 이용해 배열의 인덱스를 구함
  3. 같은 인덱스가 있다면 연결 리스트로 연결
- 잘 구현한 경우 대부분의 탐색은 O(1)이지만 최악의 경우, 모든 해시가 충돌이 발생했다고 가정하면 O(n)이 된다.
- 자바 8의 해시 테이블 구현체인 `HashMap`은 연결 리스트 구조를 좀 더 최적화해서, 데이터의 개수가 많아지면 레드-블랙트리에 저장하는 형태를 병행하기도 한다.
### 오픈 어드레싱
- 충돌 발생 시 탐사를 통해 빈 공간을 찾아나서는 방식
- 무한정 저장할 수 있는 체이닝 방식과 달리, 오픈 어드레싱 방식은 전체 슬롯의 개수 이상은 저장할 수 없다.
- 충돌이 일어나면 테이블 공간 내에서 탐사(Probing)을 통해 빈 공간을 찾아 해결하며
- 개별 체이닝 방식과 달리 모든 원소가 반드시 자신의 해시값과 일치하는 주소에 저장된다는 보장은 없다.
- 위 표를 오픈 어드레싱으로 표현
  ![IMG_9466](https://github.com/JunRain2/practice-java/assets/107318116/488f607f-88ef-4089-8bcf-e157b24658f5)
- 오픈 어드레싱 방식 중 가장 간단한 방식인 선형 탐사(Linear Proving) 방식의 예
  - 먼저 충돌이 발생할 경우 해당 위치로부터 순차적으로 탐사를 하나씩 진행한다.
  - 특정 위치가 선점되어 있으면 바로 그 다음 위치를 확인한다.
  - 탐사를 진행하다가 비어 있는 공간을 발견하면 삽입한다.
  - 가장 가까운 다음 빈 위치를 탐사해 새 키를 삽입하는 방식
- 선형 탐사 방식은 구현 방법이 간단하면서도, 의외로 전체적인 성능이 좋은 편
- 해시 테이블에 저장되는 데이터가 고르게 분포되지 않고 뭉치는 경향이 있다는 점이 큰 문제점이다.
  - 해시 테이블 여기저기에 연속된 데이터 그룹이 생기는 이러한 현상을 클러스터링(Clustering)이라고 한다.
    - 클러스터들이 점점 커지면 인근 클러스터들과 서로 합쳐지는 일이 발생
    - 해시 테이블의 특정 위치에는 데이터가 몰리게 되고, 다른 위치에는 상대적으로 데이터가 거의 없는 상태가 될 수 있다.
  - 탐사 시간이 오래 걸리게 하며, 전체적으로 해싱 효율을 떨어뜨리는 원인이 됨
- 버킷 크기(전체 슬롯의 개수)보다 큰 경우에는 삽입할 수 없다.
  - 기준이 되는 로드 팩터 비율을 넘어서면, 그로스 팩터(Growth Factor)의 비율에 따라 더 큰 크기의 또 다른 버킷을 생성한 후에 여기에 새롭게 복사하는 리해싱(Rehashing) 작업이 발생
  - `HashMap`의 그로스 팩터는 2
  - 로드 팩터는 0.75 -> 해시맵은 75% 이상 차면 2배 더 큰 메모리 영역을 할당
## 언어별 해시 테이블 구현 방식
- `HashMap`이 해시 테이블의 구현체이며, 연결 체이닝 방식으로 구현되어 있다.
- 연결 리스트 구조를 좀 더 최적화해서 데이터의 개수가 많아지면 레드-블랙 트리에 저장하는 형태를 병행
- 스크립트 언어의 경우는 오픈 어드레싱으로 구현하는 경우가 많다
  - 파이썬, 루비
![IMG_9467](https://github.com/JunRain2/practice-java/assets/107318116/1ff971a9-6995-4f2b-9c86-4c2d07b2e1fd)
- 오픈 어드레싱의 한 방식인 선형 탐사 방식은 일반적으로 체이닝에 비해 성능이 더 좋다.
- 슬롯의 80% 이상이 차면 급격한 성능 저하가 일어나며, 체이닝과 달리 전체 슬롯의 전체 개수 이상, 즉 로드 팩터 1 이상은 저장할 수 없다.
- 빈 공간을 탐사하는 선형 탐사 방식은 공간이 찰수록 탐사에 점점 더 오랜 시간이 걸리며, 가득 찰 경우 더 이상 빈 공간을 찾을 수 없기 때문
  - 스크립트 언어들은 오픈 어드레싱 방식을 택해 성능을 높이는 대신, 로드 팩터를 작게 잡아 성능 저하 문제를 해결