# 그래프
- 그래프란 그래프 이론에서, 객체의 일부 쌍(pair)들이 '연관되어' 있는 객체 집합 구조를 말한다.
## 오일러 경로
- 오일러의 쾨니히스베르크 다리 문제 스케치를 현대식 그래프 구조에 따라 나타낸 그림
  ![image](https://github.com/JunRain2/practice-java/assets/107318116/932b4b7f-0454-4540-9d1d-9cacda4e8593)
- A부터 D까지를 정점(Vertex), a부터 g까지느 간선(Edge)으로 구성된 그래프라는 수학적 구조를 찾아볼 수 있다.
- 오일러는 모든 정점이 짝수 개의 차수(Degree)를 갖는다면 모든 다리를 한 번씩만 건너서 도달하는 것이 성립한다고 말했다.
  - 100년이 지난 1873년 독일의 수학자 카히어홀저가 이를 수학적으로 증명 
- 이를 오일러 정리라고 한다.
- 모든 간선을 한 번씩 방문하는 유한 그래프를 일컬어 오일러 경로라고 부른다.
## 해밀턴 경로
- 각 정점을 한 번씩만 방문하는 무향또는 유향 그래프 경로를 말한다.
- 오일러 경로가 간선을 기준으로 한다면 해밀턴 경로는 정점을 기준으로 한다.
- 오일러 경로는 쉽게 문제를 찾을 수 있는 반면, 해밀턴 경로를 찾는 문제는 최적 알고리즘이 없는 NP-완전 문제로 대표적인 난제 중 하나이다.
- 해밀턴 경로 중 원래 출발점으로 돌아오는 경로를 해밀턴 순환이라고 한다.
  - 최단 거리를 찾는 문제는 알고리즘 분야에서는 외판원 문제(Travelling Salesman Problem;TSP)라고 부른다.
    - 각 도시를 방문하고 돌아오는 가장 짧은 경로를 찾는 문제, 최단 거리인 해밀턴 순환을 찾는 문제인데 최적 알고리즘이 없는 문제로 유명
    - 도시가 20개가 될때, 각 도시를 한 번씩 방문한다고 할때 가장 짧은 경로를 알기 위해서 다녀야 하는 총 경로의 수는 20!이다.
      - 약 240경 번의 경로를 다녀봐야 가장 짧은 경로를 찾을 수 있다.
> ### NP복잡도
> 앨런 튜링은 컴퓨터의 출현 가능성을 예측하여 튜링 기계(Turing Machine)라는 개념을 내놓았다.
> 튜링 기계란 긴 테이프(저장장치)에 쓰여 있는 여러 가지 기호(코드)를 일정한 규칙에 따라 바꾸는(기계어) 가상의 기계이다.
> 이후 컴퓨터과학 분야에서는 튜링 기계의 변형 모델로 비결정론적 튜링 기계(Non-Deterministic Turing Machine;NTM)을 제시되었다.
> 튜링 기계가 일련의 규칙을 엄격히 준수하며 한 가지 방식으로 걸졍론적(Deterministic)으로 동작하는 반면
> 비결정론적 튜링 기계는 다양한 선택지가 있고 이동할 수 있는 상태의 개수도 상황에 따라 여러 개가 되거나 아예 없을 수도 있다.
> ![image](https://github.com/JunRain2/practice-java/assets/107318116/a66617e9-9923-4359-b75c-df3f109c2b62)
> 튜링 기계를 이용해 문제를 풀이할 때 흔히 다항 시간(Polynomial Time) 내에 풀 수 있다고 할 수 있다.
> 다룰 수 있는 시간 범위 내에서 해결이 가능하다는 의미이다.
> 반대 의미로 지수 시간이 있으며, 지수 시간인 2^n 의 경우 조금만 n이 커져도 숫자가 엄청나게 불어나게 된다. 따라서 다항 시간 내에 풀이가 불가능해진다.
> 결정론적인 튜링 기계로 다항 시간내에 풀 수 있는 문제는 P 문제, 비결정론적 튜링 기계로 다항 시간 내에 풀 수 있는 문제는 NP라고 한다.
> 일정한 공식을 통해 한 번에 풀 수 있는 문제를 P문제, 다양한 가능성을 시도하며 풀이하는 소인수분해 같은 문제는 대표적인 NP문제라고 한다.
> NP문제는 비결정론적으로 계산하는 특성상 문제를 풀기 쉽지 않지만, 결과가 주어졌을 때 정답인지 확인하는 것은 매우 쉽다
> 즉 NP 문제는 검산이 쉬우며 비결정론적 튜링 기계뿐만 아니라 결정론적 튜링 기계로도 다항 시간 내에 검산이 가능하다.
> 이로 인해 P문제의 정의가 '다항 시간 내에 *풀이*가 가능한 문제' 라면, NP문제는 '다항 시간 내에 *검산*이 가능한 문제'
> 결정론적 튜링 기계로 다항 시간 내에 풀 수 있는 문제는 비결정론적 튜링 기계로도 다항 시간내에 플 수 있으므로, 결국 P 문제는 NP 문제의 부분집합이다.
> P가 NP의 진부분집합인지, 혹은 P와 NP가 같은지에 대해서는 아직 알려지지 않았다.
> 이 문제를 P-NP 문제라고 불리며 컴퓨터 분야의 대표적인 미해결 문제 중 하나다.
> 다항 시간 내에 풀 수 없는 문제를 다항 시간 내에 풀 수 있는 다른 문제로 환원해서 풀 수 있을 때 이를 NP-난해 문제라고 부른다.
> NP 문제이면서 NP-난해 문제는 NP-완전 문제라고 부른다.
> - 해멸틴 경로 : 한 번만 방문하는 경로
> - 해밀턴 순환 : 한 번만 방문하여 출발지로 돌아오는 경로
> - 외판원 문제 : 한 번만 방문하여 출발지로 돌아오는 경로 중 가장 짧은 문제
> 
> '해밀턴 경로 > 해밀턴 순환 > 외판원 문제'의 포함관계를 이룬다.
> 해밀턴 경로와 외판원 문제를 재정의
> 1. 해밀턴 경로는 존재하는가?
> 2. 각 도시를 방문하고 돌아오는 가장 짧은 경로를 찾아라(최단 거리 해밀턴 순환을 찾아라)
> 
> ![image](https://github.com/JunRain2/practice-java/assets/107318116/6657a863-875b-4b44-9dca-38af5b24a2a6)
>
> P != NP 인 경우와 P = NP인 경우의, NP-난해, NP-완전 문제 집합에 대한 관계
> 
> 해밀턴 경로 문제는 결정 문제로 다항 시간 안에 정답을 쉽게 검산할 수 있다. 즉 NP 문제이며 NP-난해 문제다.
> NP-완전 문제의 조건에 부합하므로 1번 문제는 NP-완전 문제다.
> 그러나 2번 외판원 문제는 답이 주어진다 해도 최단 거리인지 검산하는 것을 다항 시간 내에 할 수 없으므로 NP 문제가 아니다.
> NP-난해 문제이지만 NP 문제가 아니므로 NP-완전 문제가 아니다. 따라서 2번은 NP-난해 문제다.
> - P는 다항시간안에 풀리는 문제
> - NP는 다항시간안에 풀리지는 않지만, 일단 풀리는 문제
> - NP-hard(난해)는 다항시간 안으로 변환해야지만 풀리는 문제, 즉 변환하지 않으면 풀리지 않는 문제
> - NP-Complete(완전)은 NP이면서, NP-hard인 문제
## 그래프 순회
- 그래프 순회(Graph Traversal)란 그래픽 탐색(Graph Search)이라고도 하며 그래프의 각 정점을 방문하는 과정을 의미
- DFS와 BFS 2개의 알고리즘이 존재
  - 일반적으로 BFS에 비해 DFS가 더 널리 사용된다.
- DFS는 주로 스택으로 구현하거나 재귀로 구현하며, 백트래킹을 통해 뛰어난 효용을 보인다.
- BFS는 주로 큐로 구현하며, 그래프의 최단 경로를 구하는 문제 등에 사용된다.
- 그래프를 표현하는 방법
  - 인접 행렬(Adjacency Matrix)
  - 인접 리스트(Adjacency List)
    - 출발 노드를 키로, 도착 노드를 값으로 표현
    - 도착 노드는 여러 개가 될 수 있으므로 리스트 형태가 된다.
    - ![image](https://github.com/JunRain2/practice-java/assets/107318116/25a9fd25-cb8b-46f4-a0fa-68b1ace08f60)
      - 자바의 해시맵을 이용하면 다음과 같은 형태로 나타낼 수 있다.
```java
Map<Integer, List<Integer>> graph = new HashMap<>();

graph.put(1, Arrays.aslist(2,3,4));
graph.put(2, Arrays.aslist(5);
graph.put(3, Arrays.aslist(5));
graph.put(4, Arrays.aslist());
graph.put(5, Arrays.aslist(6, 7));
graph.put(6, Arrays.aslist());
graph.put(7, Arrays.aslist(3));
```
## DFS(깊이 우선 탐색)
- 스택 보다 재귀를 이용하면 좀 더 간단하게 구현할 수 있다.
### 재귀 구조로 표현
```java
public List<Integer> recursiveDFS(int v, List<Integer> discovered){
	// 현재 노드 저장(전위 순회)
  discovered.add(v);
  //주변 노드 반복
  for (Integer w : graph.get(v)) {
	  //아직 처리되지 않은 노드라면 깊이 기반 탐색 진행
    if (!discovered.contains(w)) {
      discovered = recursiveDFS(w, discovered);
    }
  }
  // 모든 깊이를 탐색하면 리턴
  return discovered;
}
```
- 정점 v의 모든 인접 유향 간선들을 반복
- 방문했던 정점, 즉 `discovered` 를 계속 누적된 결과로 만들기 위해 리턴하는 형태만 받아오도록 처리
![image](https://github.com/JunRain2/practice-java/assets/107318116/10de94c6-423d-4aab-8b5e-2a611c413325)
- 막다른 곳에 도달할 떄까지 연속으로 진행되는 탐색이 총 세 번에 걸쳐 진행 
- 1 -> 2 -> 5 -> 6 까지 진행되고 그다음 되돌아 나갔다가
- 다음번 탐색 7 -> 3
- 다시 되돌아 나가 마지막으로 루트까지 거슬러 올라가서 4를 탐색하고 종료하게 된다.
- 각 노드의 탐색 결과를 전위 순회로 저장했을 때 최종 결과는 1 -> 2 -> 5 -> 6 -> 7 -> 3 -> 4
### 스택을 이용한 반복 구조로 표현
- 스택을 이용해 모든 인접 간선을 추출하고 다시 도착점인 정점을 스택에 삽입하는 구조로 구현

```java
import java.util.ArrayDeque;
import java.util.ArrayList;

public List<Integer> iterativeDFS(int v) {
  // 결과 노드를 저장할 리스트 선언
  List<Integer> discovered = new ArrayList<>();
  Deque<Integer> stack = new ArrayDeque<>();
  // 현재 노드를 스택에 삽입
  stack.push(v);
  // 스택이 모두 비워질 때까지 반복
  while (!stack.isEmpty()) {
	  // 스택에서 추출
    v = stack.pop();
	// 이미 방문한 노드가 아니라면 방문 노드에 추가하고 주변 노드를 모두 스택에 삽입
    if(!discovered.contains(v)) {
      discovered.add(v);
	  // 현재 노드에서 연결된 모든 주변 노드를 스택에 삽입
      for (int w : graph.get(v)) {
        stack.push(w);
      }
    }
  }
  // 더 이상 탐색할 노드가 없으면 리턴
  return discovered;
}
```
- 반복 구현은 빈틈 없어 보이던 재귀에 비해 우아함이 떨어지고 코드도 더 길어지지만 좀 더 직관적이라 이해하기는 훨씬 쉽다.
- 실행 속도 또한 더 빠른 편
- 재귀 구현은 반복으로, 반복 구현은 재귀로서 바꿔서 알고리즘을 구현할 수 있다.
- 탐색 결과
  - `[1, 4, 3, 5, 7, 6, 2]`
  - 재귀와 순서가 다르다
  - 재귀 DFS는 사전식 순서로 방문했는 데 반해 반복 DFS는 역순으로 방문했다.
  - 스택으로 구현하다 보니 가장 마지막에 삽입된 노드부터 꺼내서 반복하게 되고 이 경우 인접 노드에서 가장 최근에 담긴 노드
  - 즉 가장 마지막 노드부터 방문하기 때문
  - 인접 노드를 한꺼번에 추가하는 형태이기 때문에 자칫 BFS가 아닌가 헷갈릴 수 있지만, 깊이 우선으로 탐색한다는 점에서 DFS가 맞다
  - 만약 BFS라면 `[...,4, 3, 5, ...]`  순서가 아니라 `[... , 4, 3, 2, ...]` 순서가 되어야 할 것이다.
## BFS(너비 우선 탐색)
- 최단 경로를 찾는 다익스트라 알고리즘 등에 매우 유용하게 쓰인다.
### 큐를 이용한 반복 구조로 구현

```java
import java.util.ArrayList;
import java.util.LinkedList;

public List<Integer> iterativeBFS(int start_v) {
  // 결과 노드를 저장할 리스트 선언
  List<Integer> discovered = new ArrayList<>();
  // 시작 노드 삽입
  discovered.add(start_v);
  // 큐는 인터페이스이며 자료형 선언은 LinkedList 사용
  Queue<Integer> queue = new LinkedList<>();
  // 시작 노드 삽입
  queue.add(start_v);
  // 큐가 모두 비워질 때까지 반복
  while (!queue.isEmpty()) {
	  // 큐에서 추출
    int v = queue.poll();
	// 현재 노드에서 연결된 모든 주변 노드를 큐에 삽입
    for (int w : graph.get(v)) {
		// 이미 방문한 노드가 아니라면 방문 노드에 추가하고 주변 노드를 모두 큐에 삽입
      if(!discovered.contains(w)) {
		  discovered.add(w);
		  queue.add(w);
	  }
    }
  }
  // 더 이상 탐색할 노드가 없으면 리턴
  return discovered;
}
```
- 탐색 결과
  - `[1, 2, 3, 4, 5, 6, 7]`
### 재귀 구현 불가
- BFS는 재귀로 구현할 수 없다.
- 큐를 이용하는 반복 구현만 가능
- 별도의 자료형을 사용한다든지 해서 BFS와 동일한 형태로 탐색하도록 구현은 가능하지만 일반적인 케이스는 아니다.
## 백트래킹
- 백트래킹은 DFS 보다 좀 더 넓은 의미를 지닌다.
- 백트래킹은 해결책에 대한 후보를 구축해 나가다 가능성이 없다고 판단되는 즉시 후보를 포기(Backtrack)해 정답을 찾아가는 범용적 알고리즘으로, 제약 충족 문제(Constraint Satisfaction Problem) 등에 유용
- 백트래킹은 탐색을 하다가 더 갈 수 없으면 왔던 길을 되돌아가 다른 길을 찾는다는 데서 유래
- DFS와 같은 방식으로 탐색하는 모든 방법을 뜻하며, DFS는 백트래킹의 골격을 이루는 알고리즘이다.
- 주로 재귀로 구현하며, 알고리즘마다 DFS 변형이 조금씩 일어나지만 기본적으로 모두 DFS의 범주에 속한다.
- 기본적으로 백트래킹은 가보고 되돌아 오고를 반복한다.
- 운이 좋으면 한번에, 최악의 경우 모든 경우를 다 거친 다음에 도달할 수 있다.
  - 브루트 포스와 유사
  - 한 번 방문 후 가능성이 없는 경우 즉시 후로블 포기한다는 점에서 브루트 포스보다는 훨씬 우아한 방식
- 트리의 가지치기(Pruning)
  - 불필요한 부분을 일찍 포기한다면 탐색을 최적화 할 수 있기 때문에 가지치기는 트리의 탐색 최적화 문제와 관련이 있다.
## 제약 충족 문제
- 백트래킹은 제약 충족 문제(Constraint Satisfaction Problem;CSP)를 풀이하는데 필수적인 알고리즘
- 가지치기를 통해 제약 충족 문제를 최적화 할 수 있다.
- 수 많은 제약 조건을 충족하는 상태를 찾아내는 수학 문제를 일컫는다.
- 스도쿠와 같은 문제를 떠올리면 더 이해가 쉽다.
  - 1에서 9까지 숫자를 한 번만 넣는(제약 조건 충족) 정답(상태)을 찾는 문제, 이러한 문제 유형을 제약 충족 문제라 일컫는다.